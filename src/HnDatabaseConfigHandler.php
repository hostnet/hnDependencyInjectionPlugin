<?php
namespace Hostnet\HnDependencyInjectionPlugin;

use Doctrine\DBAL\Connection;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Alternative for the \sfDatabaseConfigHandler, it reads the config in the
 * Symfony2 format
 *
 * If you want to use this
 * Let your ApplicationConfiguration extend the
 * Hostnet\HnDependencyInjectionPlugin\ApplicationConfiguration
 *
 * If you want to develop on this class, please note that this is very early in
 * the sf1 initialization
 * So you can't use much more then sfConfig::get('sf_environment');
 *
 * @author Nico Schoenmaker <nico@hostnet.nl>
 */
class HnDatabaseConfigHandler
{

    /**
     * @var ContainerInterface
     */
    private $container;

    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
    }

    /**
     * @see sfConfigHandler::execute()
     * @return string PHP code
     */
    public function execute()
    {
        $debug = $this->container->getParameter('kernel.debug');

        $connections = array();
        if (! $this->container->hasParameter('hn_entities_enable_backwards_compatible_connections')
            ||  $this->container->getParameter('hn_entities_enable_backwards_compatible_connections')
        ) {
            $connections = $this->container->get('doctrine')->getConnections();
        }

        if (strpos(SYMFONY_VERSION, '1.1.') === 0) {
            $output = $this->createSymfony11Output($connections);
        } else {
            if (strpos(SYMFONY_VERSION, '1.3.') === 0
                || strpos(SYMFONY_VERSION, '1.4.') === 0
            ) {
                $output = $this->createSymfony14Output($debug, $connections);
            } else {
                throw new \DomainException(
                    'Untested Symfony version ' . SYMFONY_VERSION .
                    ', but maybe one of the others will work'
                );
            }
        }
        // compile data
        return sprintf(
            "<?php\n// auto-generated by hnDatabaseConfigHandler\n// date: %s\n\n%s\n",
            date('Y/m/d H:i:s'),
            $output
        );
    }

    private function createSymfony11Output(array $connections)
    {
        $output = '';
        foreach ($connections as $name => $connection) {
            $config = array(
                'dsn' => $this->format11DSN($connection),
                'name' => $name
            );

            $output .= sprintf(
                '$this->setDatabase(\'%s\', new %s(%s));',
                $name,
                $this->getPropelClass(),
                var_export($config, true)
            );

            $output .= PHP_EOL . PHP_EOL;
        }
        return $output;
    }

    private function createSymfony14Output($debug, array $connections)
    {
        $output = 'return array(' . PHP_EOL;

        foreach ($connections as $name => $connection) {
            /* @var $connection Connection */

            $params = $connection->getparams();

            $dsn = sprintf(
                '%s:dbname=%s;host=%s;port=%s',
                $this->getPropel14DriverName($params['driver']),
                $connection->getDatabase(),
                $params['host'],
                $params['port']
            );

            $config = array(
                'classname' => $this->getClassname($name, $debug),
                'dsn' => $dsn,
                'username' => $params['user'],
                'password' => $params['password'],
                'persistent' => true,
                'pooling' => true,
                'encoding' => 'utf8',
                'name' => $name
            );

            $output .= sprintf(
                "'%s' => new %s(%s),",
                $name,
                $this->getPropelClass(),
                var_export($config, true)
            );

            $output .= PHP_EOL . PHP_EOL;
        }

        $output .= ');';
        return $output;
    }

    /**
     * @todo make "sfPropelDatabase" dynamic, specific for each connection
     * @return string
     */
    private function getPropelClass()
    {
        return 'sfPropelDatabase';
    }

    /**
     * @param Connection $connection
     * @return string
     */
    private function format11DSN(Connection $connection)
    {
        $params      = $connection->getParams();
        $driver_name = $this->getPropel12DriverName($params['driver']);
        if ($params['driver'] === 'pdo_sqlite') {
            return sprintf(
                '%s://hack.nl/%s',
                $driver_name,
                $connection->getDatabase()
            );
        }

        if (!empty($params['unix_socket'])) {
            return sprintf(
                '%s://%s:%s@localhost/%s?socket=%s&encoding=%s',
                $driver_name,
                $params['user'],
                $params['password'],
                $connection->getDatabase(),
                $params['unix_socket'],
                isset($params['charset']) ? $params['charset'] :  'utf8'
            );
        }

        return sprintf(
            '%s://%s:%s@%s%s/%s?encoding=%s',
            $driver_name,
            $params['user'],
            $params['password'],
            $params['host'],
            $params['port'] ? ':' . $params['port'] : '',
            $connection->getDatabase(),
            isset($params['charset']) ? $params['charset'] :  'utf8'
        );
    }

    /**
     * Return the proper drivername for Propel version 1.2
     * If the mysql extension is not loaded, fall back to
     * mysqli, thus being compatible with PHP 7.
     *
     * @throws \DomainException
     * @throws \RuntimeException
     * @return string
     */
    private function getPropel12DriverName(string $driver)
    {
        switch ($driver) {
            case 'pdo_mysql':
                if (extension_loaded('mysql')) {
                    return 'mysql';
                } elseif (extension_loaded('mysqli')) {
                    return 'mysqli';
                }
                throw new \RuntimeException('The mysql and mysqli extension both not loaded, need one of them.');
            case 'pdo_pgsql':
                if (extension_loaded('pgsql')) {
                    return 'pgsql';
                }
                throw new \RuntimeException('The pgsql extension is not loaded.');
                return 'pgsql';
            case 'pdo_sqlite':
                if (function_exists('sqlite_open')) {
                    return 'sqlite';
                }
                throw new \RuntimeException('The sqlite extension is not loaded.');
            default:
                throw new \DomainException(sprintf('Unknown driver "%s"', $driver));
        }
    }

    /**
     * @throws \DomainException
     */
    private function getPropel14DriverName(string $driver): string
    {
        $lookup_table = array(
            'pdo_mysql' => 'mysql',
            'pdo_pgsql' => 'pgsql',
            'pdo_sqlite' => 'sqlite'
        );

        if (isset($lookup_table[$driver])) {
            return $lookup_table[$driver];
        }
        throw new \DomainException(sprintf('Unknown driver "%s"', $driver));
    }

    /**
     * @param string $name
     * @param bool $debug
     * @return string
     */
    private function getClassname($name, $debug)
    {
        if ($this->container->hasParameter($name . '_database_classname')) {
            return $this->container->getParameter($name . '_database_classname');
        }
        return $debug ? 'DebugPDO' : 'PropelPDO';
    }
}
